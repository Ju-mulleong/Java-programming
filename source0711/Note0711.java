package source0711;

public class Note0711 {
}

/*
과제
row[0]: 'D' 에서 for i-- 등 i줄이는 식으로도 사용가능
문자열을 받아서 행과 열로 바꾸기(좌석 문자열의 길이가 2인 경우)
하드코딩 하지 말기, 확장성 고려, 좌석의 개수가 바뀌더라도 기능하도록

문자열의 길이 2개, 3개 다르다

객체를 바깥에서 만드는 이유

Scanner는 0번 눌렀을때만 꺼지게

메뉴 항공사마다 맨 위 이름만 다른것

메인메뉴 서브메뉴 분리(지금은 같지만, 항공사별로 예약조건 다를수도있다.)

0~4가 아니라 다른 입력값일때,
catch InputmismatchException로(강의자료에 있다)
잘못된 메뉴선택입니다

==============================================
날짜와 시간 클래스
Date 클래스
    Date()생성자는 컴퓨터의 현재 날짜를 읽어 Date 객체로 만듦

Calendar 클래스
    java.util 패키지 내에 '추상 클래스'로 정의되있음
    객체 직접 생성 x, getInstance() 메소드 이용

LocalDateTime 클래스
    날짜와 시간 조작 가능

날짜와 시간 클래스는 전체적으로 휙휙 넘기심

형식 클래스

Format 클래스
    숫자 또는 날짜를 원하는 형태의 문자열로 변환해주는 기능 제공

12장 남은거는 다 전체적으로 빨리 넘기심

==================================================
제네릭 은 상당히 어려워요
이해만 하면된다

Object 타입의 필드를 선언할 수 있다.
당연히 모든 타입의 객체 전달 가능
강제 형변환을 거쳐서 사용
    하지만 모든 종류의 클래스를 일일히 조사할 수 없다.

제네릭 사용
    결정되지 않은 타입을 파라미터 T(<T>)로 정의 - 다른 알파벳도 가능하지만, 일반적으로 Type의 T
    객체를 생성하는 시점에서 타입을 정의

제네릭의 기본 개념
    모든 종류의 데이터 타입을 다룰 수 있는 일반화된 타입의 매개변수
    E가 특정 타입으로 변한다

제네릭 타입
    "타입을 일반화"하는 것

    구체화
        제네릭 타입의 클래스 변수를 선언할 떄 구체적인 타입을 대입
        실제 객체가 생성되는 시점에 구체적인 타입으로 대체

제네릭 객체 생성 과정
    객체를 생성할 때, 구체적인 타입 대입한다.
    컴파일러에 의해 이루어짐
    타입 매개변수 <T>에 '기본타입'은 사용 불가능(클래스 타입만 사용)

제네릭 타입 매개 변수
    <와 > 사이에 하나의 알파벳 대문자로 사용

    일반적으로 어떤 걸 표시할 때 어떤 문자를 쓸지 많이 사용하는문자가 있다

    제네릭 타입을 사용하는 이유
        재사용성 증가
        다양한 객체 생성

제네릭 타입 예제:Object 타입은 권장하지 않는 방식(전구)
    MyType 클래스 안에 equals()메소드가 재정의되어있지 않으면,
    Object의 equals()호출

    breakpoints 걸고 at into 로 들어가면 좀 더 확실하게 볼 수 있음
    이해만 하기, 실사용 이렇게 잘 안함

제네릭 메소드
    클래스의 일부 메소드만 제네릭으로 구현
    <T>는 단순하게 '이 메소드가 제네릭 메소드다' 라는 것만 알려주는 것
    실제적인 리턴타입은 매개변수 타입에 따라 결정됨

    클래스 전체가 아니라 메소드 하나만 제네릭하게 만든 것
    전달된 파라미터의 타입을 보고 T의 자료형이 결정됨

제한된 타입 파라미터
    특정 타입과 자식, 또는 구현 관계에 있는 타입만 대체할 수 있는 경우
    누누히 말하지만 이해하는데 집중하자.

와일드카드(?)타입
    범위에 있는 모든 타입으로 대체
    ?는 모든 것을 의미
    이렇게 쓴다는 것 만 알자
    중요한건 뒤의 컬렉션

실제로 그나마 중요한건 8p정도
=================================================
컬렉션 프레임워크

Collection
    객체들을 효율적으로 추가, 삭제, 검색할 수 있도록 만들어 놓은 java.util 패키지
    가변 크기의 컨테이너
        요소의 개수에 따라 크기 자동 조절
        추가, 삭제 시 자동으로 크기가 조절
    컬렉션은 제네릭 기법으로 구현됨
    컬렉션의 요소는 '객체'만 가능
        기본 타입은 wrapper기법으로 객체로 자동 변환

    주요 인터페이스
        List:   순서 유지하고 저장, 중복 저장 가능
        Set:    순서 유지하지 않음, 중복 저장 안됨
        Map:    키와 값으로 구성된 엔트리 저장, 키는 중복 저장 안됨

List컬렉션
    객체를 인덱스로 관리, 인덱스로 객체를 검색, 삭제 가능

    List 인터페이스의 메소드
        가장 많이쓰는것 :추가할때 add, 가져올 때 get
        remove는 인덱스를 받는것, 객체명을 받는 것 두 가지 있다.

ArrayList<E>
    가변 크기 배열을 구현한 클래스
        <E>대신에 요소로 사용할 특정 타입으로 구체화

    객체 자체를 저장하는 것이 아니라, 객체의 번지를 저장
        동일한 객체를 중복 저장 시 동일한 번지가 저장

    기본적으로
    ArrayList() 사용, 크기가 0인 ArrayList()생성, 필요할 때 추가

    get()메소드를 이용하여 요소 검색

    ArrayList의 인덱스는 삭제/삽입 시 자동 조정됨
        그래서 빈번하게 삽입, 삭제 일어난다면 LinkedList가 적당

컬렉션 자동 boxing/unboxing
    지금은 자동으로 작동한다.

ArrayList의 메소드
    int indexOf(Object obj) : Object obj와 같은 첫 번째 요소의 인덱스 리턴,
                                obj가 ArrayList에 없으면 -1 리턴
    toArray() : 리턴

11p ArrayList 예제
    ArrayList<Board> list= new ArrayList< > (); <>안에 Board 생략된것


Vector<E>
    예전버전의 호환성을 위하여 유지
    지금은 ArrayList나 LinkedList를 더 많이 사용

    한 번에 하나의 스레드만 접근하도록 막아주는 역할

    int capacity() 벡터의 현재 용량 리턴
        capacity()는 잡아놓은 용량, 실제용량과 다를 수 있다.
        실습에서 확인 가능


Vector와 ArrayList 비교
    배열이 꽉 찼을시, 증가되는 용량이 다르다

컬렉션을 매개변수로 받는 메소드
    타입 그대로 받는다고 생각

19p 주석처리해놓은 코드 아래와 번갈아 주석처리해가며 ArrayList와 Vector 비교


LinkedList
    인접 객체를 체인처럼 연결해서 관리
    객체의 삽입, 삭제가 빈번히 발생할땐 ArrayList보다 유리

LinkedList와 ArrayList 비교


과제hw03
    Collections.shiffle(list)
    카드 나눠줄때마다 remove로 없애야됨
    나눠준 카드가 동일하면 0점

    Alice
        holdingCardList:선수가 가지고 있는 카드 목룍
                        딜러가 줄때마다 2장씩 추가
        openCardList:   테이블에 공개한 카드 목록

        당연히 openCardList는 계속 는다

    main()함수 가 게임테이블 이라고 생각
    enter뿐 아니라 아무키 가능

    딜러가 6장 미만이면 2개씩 3명에게 나눠줄수 없으므로 게임 종료
    player의 openCardList 출력

    단계별로 수행



 */
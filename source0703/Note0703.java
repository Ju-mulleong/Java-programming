package source0703;

public class Note0703 {

	public static void main(String[] args) {
		
	}

}


/*
 * 객체를 참조하는 배열
 * 	참조 타입 배열 
 * 		각 항목에 객체의 번지를 저장
 * 	strArray[0] = "Java";는
 * 	strArray[0] = new String("Java");
 * 	new 생략된거
 * 		하지만 둘의 용도 살짝 다르다
 * 		new를 사용하면 리터럴이 같더라도 별도의 메모리공간을 '생성'한다 new 직접적으로 썼으니까.
 * 		반대로 위에거는 만약에
 * 			strArray[1] = "Java";였다면
 * 			별도의 객체를 생성하지않고 처음에 생성된 객체의 주소를 참조
 * 
 * 얕은 복사
 * 	메소드에 파라미터로 배열 전달과 동일.
 * 	단순히 주소값만 복사하므로 동일한 메모리 공간을 '공유'
 * 	원본이나 복사된 배열이 변경되면, 서로 값이 변경됨! 복사된 배열도 원본에 영향준다
 * 
 * 깊은 복사
 * 	별도의 복사본을 생성
 * 	복사된 배열이나 원본 배열이 변경되어도 '서로 영향을 미치지 않음'
 * 	
 * 	static으로 선언해놓으면 프로그램 실행전에 미리 메모리에 올라가있다.
 * 	2차원 배열을 deep copy할때는 for문등을 사용하여 각 행 단위로 deepcopy 수행해야됨.
 * 
 * 
 * for-each문
 * 	마치 파이썬에서 for i in list 와 유사
 * 	for(변수:배열){
 * 	이면 배열에서 하나씩 뽑아서 변수에 넣는다.
 * 	배열 길이 적어 줄 필요 없 변수 타입은 처음에 선언해줘야됨, 그냥 for 처럼
 * 	원소 전체 합 구하는 거 그런거에서 좀 좋을듯?
 * 	
 * 2차원 배열에서 for-each는
 * 	1행을 전달한다.
 * 
 * 
 * 문자열 타입(String)
 * 	==사용하면 문자열의 '주소 비교'다. 같은 객체를 참조할때만 true반환
 * 	위에서 배열의 경우와 유사하게, new를 사용하면 같은 리터럴이라도 다른 주소에 새로운객체 생성,
 * 	new 안쓰면 (자바 문자열 상수 풀 에서 참조하므로) 같은 리터럴일경우 같은 주소를 참조한다.
 * 	문자열의 값을 비교할려면 str1.equals(str2)사용 이 메소드는 boolean타입을 리턴한다.
 * 
 * 	
 * 문자열에서 문자 추출 메소드: charAt()	//모든 메소드는 .function()형태인듯
 * 	char charAt(int index)
 * 
 * char charValue = topic.charAt(3);
 * 
 * 문자열 길이: length()
 * 	해당 문자열의 길이를 리턴
 * 
 * int lengthValue = topic.length();
 * 
 * 문자열 대체: replace()
 * 		(Charsequence는 일단 그냥 문자열 타입의 상위개념 이라고 생각(String, StringBuffer, StringBuilder)포함)
 * 	
 * 		String replace(CharSequence target, CharSequence replacement)
 * 		target 문자열을 찾아서 repalcement로 '모두 교체' 해서 반환
 * 		기존 문자열은 변경 없고, 교체된 새로운 문자열을 리턴
 * 		target문자열을 발견하지 못하면 원본 문자열 리턴
 * 
 * String newStr = topic.replace(source0628.Hello,Bye);
 * 		topic 문자열에서 source0628.Hello 라는 단어를 모두 찾은 뒤 Bye로 바꾼 문자열을 리턴
 * 
 * 		
 * 	
 * 
 * 문자열 잘라내기: substring()
 * 	파이썬의 슬라이싱 느낌 range(0,5,1) 이런 느낌으로 썼었는데
 * 	이것도 유사, 시작 인덱스부터 끝 전 인덱스까지 이건 스텝 1로 고정인듯?
 *  
 *  
 * 문자열 찾기: indexOf()
 * 	해당 문자열에서 특정 문자나 문자열을 검색
 * 	주어진 문자나 문자열이 시작되는 '첫 번째 인덱스'를 리턴 인덱스 리턴이니까 정수겠지?
 * 	검색 실패시 -1을 리턴
 *  
 *  
 * 문자열 포함 여부 확인: contains()
 * 	해당 문자열이 주어진 문자열을 포함하면, true 그렇지 않으면 false 리턴
 *  
 *  
 * 문자열 찾기 예제 (실습) 시험 나올듯
 * 	
 *  
 * 문자열 분리: split()
 * 	파이썬과 유사 
 * 	기호, 공백등을 기준으로 문자열을 분리 후 
 * 	'분리된 문자열을 String 배열에 저장'후 String 배열을 리턴
 *  여러 분리조건 사용가능 : or(|)연산자 사용 
 *  		ex) split("<|>")
 *  
 * main() 메소드의 String[] 매개변수 용도! 여기 중요
 *  public: 다른 클래스에서 메소드 접근 허용
 *  static: 객체 생성 전에 호출 가능
 *  		main 에서는 반드시 사용
 *  void: main()은 리턴값 없으
 *  String[] args: 문자열 배열 매개변수
 *  		명령행 인자의 전달
 *  		1) javac source0628.Hello.java ->컴파일 하여 source0628.Hello.class 생성
 *  		2) java source0628.Hello
 *  		args에 스트링 배열로 저장하는데, 각각은 문자열이며 공백을 기준으로 분리하여 저장
 *  
 * 
 *  터미널 사용에 익숙해져야한다. 
 *  그리고 회사가면 다 Linux 쓴다, 미리 익숙해지자
 *  
 *  
 * == ===============================================================
 *  클래스
 *  
 *  객체 지향 프로그래밍(Object Oriented Programming)
 *  	객체들을 생성하고, 각 개체에 포함된 데이터(필드)와 기능(메소드)을 상호 호출해서 프로그램을 구성하고 동작
 *  
 *  클래스
 *  	객체를 만들기 위한 설계도
 *  
 *  객체
 *  	클래스의 모양그대로 만들어낸 실체
 *  	
 *  객체의 특성
 *  	속성: 필드
 *  	동작: 메소드(클래스 내부에 있는 함수)
 *  
 *  oop에서 가장 중요한건 클래스를 어떻게 설계하느냐(객체 모델링)
 *  
 *  객체의 상호작용
 *  	객체들간 서로 상호작용, 호출 및 리턴
 *  객체들간의 관계:사용, 상속, 집합 등
 *  
 *  객체 지향 프로그래밍의 목적
 *  	소프트웨어를 빠른 속도로 생산할 필요성 증대
 *  	상속, 다형성, 객체, 캡슐화 등 ' 소프트웨어 재사용' 을 위한 여러 장치 내장- 소프트웨어 생산성 향상
 *  
 *  객체 지향 프로그래밍의 특징
 *  	캡슐화:	객체를 캡슐로 싸서 내부를 볼 수 없게 하는 것
 *  			사용 이유:외부의 잘못된 접근으로부터 객체를 보호:정보 은닉
 *  					-접근 제한자 사용(숨김:private, 공개:public)
 *  
 *  	상속:		상위 객체(부모)의 속성이 하위 객체(자식)에 물려짐(private 제외)  
 *  				-자식이 자식을 낳을수록 무조건 확장된다?
 *  			사용이유: 코드 재사용성 높임, 유지 보수 시간 최소화
 *  			우리가 자연스럽게 많이 사용하는 클래스들이 엄청나게 확장된 클래스들을 재사용하는것	
 *  			부모 클래스 = 슈퍼 클래스
 *  			자식 클래스 = 서브 클래스
 *  			
 *  				ex) class Human extend Animal 
 *  						서브 클래스 Human은 슈퍼 클래스 Animal을 상속한 것
 *  						자동으로 부모클래스의 객체는 포함되므로 구현 할 필요 없다.	
 *  			
 *  	다형성:	사용방법은 동일하지만, 실행 결과가 다양함 
 *  			ex)println()은 println(float),println(boolean)
 *  			같은 이름의 메소드가 클래스나 객체에 따라 다르게 동작하도록 구현
 *  			한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있음
 *  			
 *  			다형성 사례 : 	메소드 오버로딩: 같은 이름이지만 다르게 작동하는 여러 메소드(println)
 *  						메소드 오버라이딩: 부모 클래스의 메소드를 자식클래스마다 다르게 구현(재정의)
 *  
 *  
 *  클래스 선언 : 객체를 생성하기 위한 설계도를 작성하는 작업
 *  			ex) new Scanner(system.in)가 생성자를 호출
 *  
 *  			!!!클래스 이름은 첫 문자를 대문자로 사용!!!
 *  			public class :공개 클래스
 *  
 *  하나의 프로젝트 안에 main 하나 강력하게 권장, 둘 이상이어도 오류는 안나지만 미리 습관화
 *  main은 최소화하는게 중요, 객체 정의 정도만, 실행클래스는 컨트롤타워 역할
 *  그외의 각각 라이브러리 클래스 안의 각각 동작
 *  
 *  
 *  ==============0704 같은 클래스부분이라 이어서 작성===================
 *  
 *  내부에서 메소드 작성할때는 static 필요없음, static은 객체를 미리 생성할때 사용
 *  첫 장 source0628.Hello 참고
 *  
 *  다시 한번 짚자, 클래스는 설계도, 객체가 물건, 생성자는 노동자쯤 되나?
 *  클래스의 구성 멤버
 *  	필드, 생성자, 메소드
 *  	필드: 	클래스 선언 아래에 선언된 변수(객체의 데이터를 저장)
 *  			전역변수로 사용하고 싶은 경우 반드시 클래스이름 바로 밑에다 선언
 *  
 *  	생성자: 	new 연산자로 객체 생성시 객체 및 필드 초기화
 *  			지금까지는 생성자 안썼어도 자바가 자동으로 처리했지만 앞으로는 습관화
 *  			생성자 이름은 클래스이름과 동일, 리턴 없음
 *  
 *  	메소드:	객체가 수행할 동작, 객체 내부의 함수	
 *  
 *  
 *  .으로 클래스 멤버 함수 호출 가능
 *  
 *  필드 선언과 필드 초기화는 다르다.
 *  동시에 하는것 권장 x 필드 값이 전부 같은 경우에만 필드 선언시 초기화
 *  클래스명 아래에 필드 선언만, 필드값 초기화는 생성자에게
 *  
 *  생성자 파라미터명 필드 변수명과 똑같이하고, this로 자기 자신을 의미하도록 할 수 있음
 *  this();로 같은 클래스 내부의 다른 생성자 호출 가능
 *  
 *  생성자 오버로딩
 *  	매개변수의 타입, 개수, 순서를 다르게 하여 생성자를 여러개 선언
 *  	중복 코드를 this()를 사용하여 줄이는게 중요
 *  
 *  메소드 선언과 호출
 *  	메소드 이름:	소문자로 시작(클래스는 대문자로 시작)
 *  				캐멀 스타일(소문자+대문자)로 작성
 *  
 *  ex) public int plus(intx, inty){
 *   		blahbalh
 *   {
 *  
 *  public은 접근 여부 ,int는 리턴값의 타입
 *  
 *  
 *  
 *  	메소드 호출: 	클래스 내부에서 메소드를 호출할때는 dot(.)안써도 됨
 *  				생성자 안에서 다른 메소드를 호출할 수도있다.
 *  
 *  
 *  가변길이 매개변수-참고만, 잘 안씀 나중에 배우는 컬렉션이나 배열을 더 많이 사용
 *  
 *  return문
 *  	메소드의 실행 강제 종료, 호출한 곳으로 돌아감. return문뒤에 실행문 있을 경우 오류
 *  
 *  메소드는 객체와 다른 공간에 저장, 같은 메소드일경우 여러 객체들이 공유(메모리 아낌)
 *  
 *  정적 멤버(static 필드, static 메소드)
 *  	static 변수 클래스내에서의 전역변수 느낌
 *  	static 메소드 main()이 대표적
 *  	객체마다 생성되는게 아니라, 클래스당 하나만 생성됨.
 *  	객체를 생성하지 않고 사용 가능
 *  
 *  
 *  final 키워드
 *  	
 *  	상수나, 메소드, 클래스를 정의한 다음 변경하지 못하게 할 때 사용
 *  	
 *  	final 필드 : 한 번 저장되면 수정 불가능, 선언과 함께 초기값 할당하거나, 생성자에서 초기값 할당 가능 
 *  	final 메소드:재정의 못하게 정의
 *  	final 클래스: 상속을 못하게 클래스를 정의
 *  
 *  
 *  static final
 *  	클래스 변수의 상수 선언 시 사용
 *  	객체마다 저장할 필요 없고, 여러개의 값을 가질 수 없기 때문에 사용
 *  	객체 생성되기 전에 만듦, 생성자에서 초기화 불가능
 *  
 *  
 *  객체 배열: 객체를 원소로 가지는 배열
 *  	1. 배열 생성(new)
 *  	2. 배열 원소마다 객체 생성(new)
 *  	
 *  패키지
 *  	폴더와 유사
 *  	서로 관련된 클래스들을 하나의 디렉토리에 묶어 놓은 것
 *  	!!클래스의 일부분이며, 클래스를 식별하는 용도로 사용
 *  	패키지를 사용하면, 동일한 이름의 클래스 작성가능(비권장!) import로 사용
 *  	(* 애스터리스크는 모든 이라는 뜻)
 *  
 *  --중간 시험 범위--
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 *  
 */

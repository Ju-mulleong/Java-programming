package source0702;

public class Note0702 {

}

/*	close는 스캐너만.. 다른 객체들은 close 없다.
 * 
 * 
 * System.out.print(); 이거 너무 타이핑하기 길다
 * 이클립스 기준
 * 	sysout 하고 컨트롤+스페이스하면 자동완성됨
 * 
 * 
 * Code Conventions 중요
 * 	회사마다 자체규정(구글, 오라클, 나사)
 * 	소프트웨어 생명 주기의 80%가 유지보수에 사용
 * 	개발자들이 새로운 코드를 빠르고 완벽하게 이해하는데 도움을 줌 (가독성 향상)
 * 
 * 
 * if 문
 * 	if(조건식) {
 * 	..작업문..
 * } 
 * 늘 먹던 그거, elif 대신 else if 쓴다.
 * else 는 조건식 없지만, else if 는 조건식 있는것까지 동일
 * 
 * switch문
 * 
 * switch(식)
 * 	case 값1:
 * 		실행문장1;
 * 		break;
 * 	case 값2:
 * 		실행문장2;
 * 		break;
 * 	....
 *  default:
 * 		실행문장 n;
 * }
 *
 * else if 로도 귀찮을만큼 너무 경우의 수 많으면 사용
 * case가 전부 불일치하면 default 실행
 * break 만나면 switch문 벗어나고 없으면 다음 case로 이동
 * !!중요 case 값에는 정수타입, 문자, 문자열만 가능 실수는 불가능
 * case 뒤에 실행문장과 break 생략하면 그 다음 실행문장과 break를 같이 쓰는 case라는뜻
 * 
 * 
 * 
 * 
 * for 문
 * 	for(초기문; 조건식; 빈복  후 작업) {
 * 	..작업문..
 * }
 * 
 * for(int i=0; i<array.length; i++) {
 * 
 * }
 * 
 * 초기문에 sum = 0,i=0,n=0등 여러개 선언하고 사용 가능?
 * 그냥 밑에다 선언하는게 나을듯.
 * 
 * ,이 아니라 세미콜론 사용에 주의
 * i 선언해 줘야됨, int로
 * 부동 소수점 사용 문제점떄문에 ()는 앵간하면 정수로만
 * 
 * 
 * while문
 * 	while(조건식){
 * 	...작업문
 * }
 * 
 * while(true): 무한 반복
 * 	boolean 변수 = true;로 설정해놓고 
 * 	이 변수의 값을 특정 조건문으로 false로 바꿔서 while 무한반복을 빠져나갈수도있다.
 * 
 * 
 * do-while 문
 * 	무조건 최소 1회 작업문 실행
 * 
 * do{
 * ..작업문
 * }while(조건식);
 * 
 * 
 * 문자열 하나를 문자, 정수, 16진수로 나타낼수있다.
 * 
 * break 문
 * 	반복문 '하나'만 빠져나간다.
 * 	중첩 반복문의 경우, 안쪽 반복문의 break 문이 실행되면 안쪽 반복문만 벗어남
 * 	return?
 * 
 * continue 문
 * 	반복문을 빠져 나가지 않으면서 다음 반복으로 진행
 * 	그 이후의 문장 실행x, 다음 반복으로 넘어감 주로 if와 함께 특정조건에서 사용
 * 
 * 
 * ================================================
 * 
 * 참조 타입
 * 	기본 타입: 값 자체를 저장 (int n = 10;) 
 * 		stack에 값을 저장
 * 	참조 타입: 실제 메모리의 번지(주소)를 저장 (String str = "source0628.Hello")
 * 		heap에 객체를 저장, stack에 이 객체의 주소(번지)를 저장
 * 
 * 	new Scanner(System.in);에서 new가 메모리 공간을 할당하는것(객체)
 *  객체는 무거워서 객체를 직접가져오는것보다 객체가 생성된 메모리 번지를 참조한다?
 *  
 *   
 *  참조타입 변수의 ==, !=연산
 *  	제일 중요한건 참조타입 변수의 비교는 '주소'를 비교한다, '값'이 아니라
 *  	그래서 String은 == 쓰지 말라고 한 것, 겉으로 보이는 값은 같아도
 *  	참조하는 주소가 다르기 때문에
 *  	같은 주소를 참조하면 당연히 동일한 객체이기 때문에 값도 같겠지만,
 *  	객체의 주소가 다르더라도 객체의 값은 같을 수 있기 때문에
 *  	
 * null값
 * 	참조 타입 변수만 선언한 경우, null값 가짐
 * 	참조 타입 변수에 객체를 생성해서 대입해야됨
 *   
 *   
 *   
 * 배열(Array)
 * 	
 * 	int[] score = { 83,90,87};
 *		배열 선언과 동시에 초기화 - new 필요없음
 *	score.length(배열의 길이) : 배열에 저장할 수 있는 항목 수
 *   
 *   일차원 배열 만들기
 *   	배열 선언과 배열 생성
 *   	배열 선언과 배열 생성 동시에 하는 것 추천
 *   	배열 선언 = 객체 배열 생성?
 *   		int[] intArray = new int[10]; //위와 헷갈리지않게 조심 이건 배열의 크기를 지정하는것
 *   		int intArray[] = new int[10];
 *   
 *   	배열 선언과 동시에 초기화 new 생략 가능(new 쓴것과 효과는 같다)
 *   	
 *   		선언과 초기화 따로따로는 못쓴다
 *   
 *   배열 인덱스		
 *   	자바에서는 인덱서 음수 못쓴다
 *   	인덱스의 범위는 0포함이다 크기가 5이면 0~4
 *   
 *   
 *   2차원 배열
 *   	int s[][] = new int[3][5];
 *   						행 열 
 *   	2차원 배열도 마찬가지로 배열 선언과 동시에 초기화를 수행할 경우, 크기를 입력하지 않음
 *   
 *   	i.length는 행의 개수
 *   	i[n].length는 n번째 행의 열의 개수 -정방행렬이 아닐수있기 때문에 이렇게 사용
 *   	
 *   
 *static은 객체 생성 이전에 사용가능 하다는 뜻
 *
 *  
 */
